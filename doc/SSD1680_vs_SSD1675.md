# SSD1680 vs SSD1675: Key Differences

## Overview

The **SSD1680** is a newer controller that is backward-compatible with SSD1675 but has important differences. Many WeAct Studio 2.13" displays use the SSD1680 even though they may be labeled as SSD1675.

## How to Identify Your Controller

If your display shows these symptoms with the SSD1675 driver:
- ❌ Screen doesn't clear completely
- ❌ Partial refresh doesn't work
- ❌ Random pixels remain after clear
- ❌ Initialization fails or times out

Then you likely have an **SSD1680** controller!

---

## Key Technical Differences

### 1. Command Set

| Feature | SSD1675 | SSD1680 |
|---------|---------|---------|
| Write RAM (B/W) | `0x24` | `0x24` (same) |
| Write RAM (RED) | `0x26` | `0x26` (same) |
| Display Update Control 2 | `0x22` | `0x22` (same) |
| LUT Write | `0x32` | `0x32` (same) |

**Most commands are the same!** The difference is in:
- Initialization sequence order
- Required vs optional commands
- Default values

### 2. Initialization Sequence

#### SSD1675 Init (Simplified)
```c
SW_RESET
DRIVER_OUTPUT_CONTROL (3 bytes)
DATA_ENTRY_MODE (1 byte)
SET_RAM_X_RANGE (2 bytes)
SET_RAM_Y_RANGE (4 bytes)
BORDER_WAVEFORM_CONTROL
TEMP_SENSOR_CONTROL
WRITE_LUT (30 bytes)
```

#### SSD1680 Init (Simplified)
```c
SW_RESET
DRIVER_OUTPUT_CONTROL (3 bytes)
DATA_ENTRY_MODE (1 byte)
SET_RAM_X_START_END (2 bytes)  // Note: slightly different command
SET_RAM_Y_START_END (4 bytes)  // Note: slightly different command
BORDER_WAVEFORM_CONTROL
DISPLAY_UPDATE_CONTROL_1       // ← SSD1680 specific!
TEMP_SENSOR_CONTROL
// LUT is optional (has good internal LUT)
```

### 3. LUT (Look-Up Table) Format

| Controller | LUT Size | Usage |
|------------|----------|-------|
| SSD1675 | 30 bytes | Required for proper operation |
| SSD1680 | 30 bytes (basic) or 70 bytes (full) | Optional - has built-in LUT |

**Key point:** SSD1680 has a better internal LUT, so you can skip loading a custom LUT entirely!

### 4. Display Update Control

#### SSD1675
```c
// Only uses DISPLAY_UPDATE_CONTROL_2
ssd1675_send_command(dev, 0x22);
ssd1675_send_data_byte(dev, 0xF7);  // Full refresh
```

#### SSD1680
```c
// Uses both CONTROL_1 and CONTROL_2
ssd1680_send_command(dev, 0x21);  // CONTROL_1
ssd1680_send_data_byte(dev, 0x00);
ssd1680_send_data_byte(dev, 0x80);

ssd1680_send_command(dev, 0x22);  // CONTROL_2
ssd1680_send_data_byte(dev, 0xF7);  // Full refresh
```

### 5. Clear Screen Implementation

The critical difference that causes incomplete clears with SSD1675 code:

#### SSD1675 Clear (Incomplete on SSD1680)
```c
void ssd1675_clear_screen() {
    memset(framebuffer, 0xFF, SIZE);

    // Write to B/W RAM only
    send_command(WRITE_RAM_BW);
    send_data(framebuffer, SIZE);

    display_update();
}
```

#### SSD1680 Clear (Complete)
```c
void ssd1680_clear_screen() {
    memset(framebuffer, 0xFF, SIZE);

    // Write to B/W RAM
    set_ram_address(0, 0);
    send_command(WRITE_RAM_BW);
    send_data(framebuffer, SIZE);

    // ALSO clear RED RAM! ← This is the key!
    set_ram_address(0, 0);
    send_command(WRITE_RAM_RED);
    send_data(framebuffer, SIZE);

    display_update();
}
```

**Why?** The SSD1680 always considers both RAM buffers during refresh. Even if your display doesn't support red pixels, residual data in RED RAM can cause artifacts.

### 6. Power Management

#### SSD1675 Deep Sleep
```c
send_command(DEEP_SLEEP_MODE);
send_data_byte(0x01);  // Mode 1
```

#### SSD1680 Deep Sleep
```c
send_command(DEEP_SLEEP_MODE);
send_data_byte(0x01);  // Mode 1: RAM preserved
// or
send_data_byte(0x03);  // Mode 2: Lower power, RAM lost
```

SSD1680 has two deep sleep modes with different power characteristics.

---

## Code Comparison

### Framebuffer Structure (SAME)

Both controllers use the same framebuffer layout:
```c
#define WIDTH  250
#define HEIGHT 122
#define BUFFER_SIZE ((WIDTH * HEIGHT) / 8)  // 3,813 bytes

// Bit layout (both controllers)
Byte[0] = pixels 0-7 of row 0
Byte[1] = pixels 8-15 of row 0
...
Byte[31] = pixels 248-249 of row 0 + padding
Byte[32] = pixels 0-7 of row 1
...
```

### Drawing Functions (SAME)

The `draw_pixel()` and `draw_rectangle()` functions are **identical** for both controllers because they only modify the framebuffer in RAM, not the hardware.

### Display Update (DIFFERENT)

This is where the main difference lies:

```c
// SSD1675
void ssd1675_display_frame() {
    set_ram_cursor(0, 0);
    send_command(WRITE_RAM);
    send_data(framebuffer, SIZE);

    send_command(DISPLAY_UPDATE_CONTROL_2);
    send_data_byte(0xF7);

    send_command(MASTER_ACTIVATION);
    wait_until_idle();
}

// SSD1680
void ssd1680_display_frame() {
    set_ram_cursor(0, 0);
    send_command(WRITE_RAM_BW);  // Explicit B/W RAM
    send_data(framebuffer, SIZE);

    // No need to write RED RAM for normal operation

    send_command(DISPLAY_UPDATE_CONTROL_2);
    send_data_byte(0xF7);

    send_command(MASTER_ACTIVATION);
    wait_until_idle();
}
```

---

## Performance Comparison

| Metric | SSD1675 | SSD1680 |
|--------|---------|---------|
| Full refresh time | ~2 seconds | ~2 seconds |
| Partial refresh | Possible with custom LUT | Better partial refresh support |
| Power consumption (active) | ~25mA | ~25mA |
| Power consumption (sleep) | ~1-2µA | <1µA (mode 2) |
| Max SPI clock | 20 MHz | 20 MHz |
| Temperature compensation | Basic | Improved |

---

## Migration Guide

If you're switching from SSD1675 to SSD1680 code:

### What Stays the Same ✅
- Pin connections
- SPI configuration
- Framebuffer format
- Drawing functions
- Bit manipulation logic

### What Changes ⚠️
- **Initialization sequence** - Add `DISPLAY_UPDATE_CONTROL_1`
- **Clear screen** - Must clear both B/W and RED RAM
- **LUT upload** - Optional (can use internal)
- **Deep sleep** - Two modes available

### Quick Migration Checklist

1. Replace `ssd1675_init()` with `ssd1680_init()`
2. Replace `ssd1675_clear_screen()` with `ssd1680_clear_screen()`
3. Replace `ssd1675_display_frame()` with `ssd1680_display_frame()`
4. Test full clear (should be completely white)
5. Test full black (should be completely black)
6. Test drawing patterns

---

## Troubleshooting

### Problem: Screen doesn't clear completely

**Cause:** Not clearing RED RAM

**Solution:**
```c
// After writing B/W RAM, also clear RED RAM
set_ram_address(0, 0);
send_command(WRITE_RAM_RED);
memset(white_buffer, 0xFF, SIZE);
send_data(white_buffer, SIZE);
```

### Problem: Display times out during init

**Cause:** Missing `DISPLAY_UPDATE_CONTROL_1` command

**Solution:**
```c
// Add this before temperature sensor control
send_command(DISPLAY_UPDATE_CONTROL_1);
send_data_byte(0x00);
send_data_byte(0x80);
```

### Problem: Display shows random dots

**Cause:** Uninitialized RED RAM

**Solution:** Always clear both RAMs during initialization

---

## Recommendation

**Use the SSD1680 driver** even if you're not sure which controller you have. The SSD1680 code is more robust and will work with both controllers in most cases. The SSD1675 code may fail on SSD1680 displays.

---

## References

- SSD1675 Datasheet: [Solomon Systech]
- SSD1680 Datasheet: [Solomon Systech]
- WeAct Studio 2.13" Display: Uses SSD1680 (confirmed)
- Waveshare 2.13" V2: Uses SSD1680
- Waveshare 2.13" V1: Uses SSD1675

---

## Summary

The SSD1680 is the **newer, better controller**. Key improvements:
- ✅ Better internal LUT
- ✅ Improved temperature compensation
- ✅ Lower power consumption
- ✅ Better partial refresh
- ✅ More robust initialization

The main "gotcha" is that **you must clear both B/W and RED RAM** even on black-and-white displays to avoid artifacts.
